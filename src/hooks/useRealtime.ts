"use client";

import { useState, useEffect, useRef } from 'react';
import { subscribeToNotes, subscribeToDossiers, subscribeToClasseurs, unsubscribeFromAll, startSubscriptionMonitoring } from '@/realtime/dispatcher';
import { supabase } from '@/supabaseClient';
// ANCIEN SYST√àME D√âSACTIV√â - Utilisation du nouveau syst√®me realtime
import { initRealtimeService, subscribeToTable as subscribeToPolling, unsubscribeFromTable as unsubscribeFromPolling, stopRealtimeService } from '@/services/realtimeService';
// import { initWebSocketService, subscribeToTable as subscribeToWebSocket, unsubscribeFromTable as unsubscribeFromWebSocket, stopWebSocketService } from '@/services/websocketService';
// import * as supabaseRealtimeService from '@/services/supabaseRealtimeService';
// import { initSSEService, subscribeToTable, unsubscribeFromTable, stopSSEService } from '@/services/sseService';
import { useFileSystemStore } from '@/store/useFileSystemStore';
import { useAuth } from './useAuth';
import { logApi } from '@/utils/logger';
import { simpleLogger as logger } from '@/utils/logger';

interface RealtimeConfig {
  userId?: string;
  type: 'polling' | 'websocket' | 'sse';
  interval?: number; // pour polling
  wsUrl?: string; // pour websocket
  token?: string; // pour websocket s√©curis√©
  debug?: boolean;
  onError?: (err: any) => void;
  /**
   * Handler g√©n√©rique appel√© √† chaque √©v√©nement WebSocket re√ßu (mode websocket uniquement).
   * Signature : (event: { type: string, payload: unknown, timestamp: number }) => void
   * L'utilisateur peut dispatcher comme il veut dans son UI ou son store.
   */
  onEvent?: (event: { type: string, payload: unknown, timestamp: number }) => void;
}

interface ChangeEvent {
  table: string;
  eventType: 'INSERT' | 'UPDATE' | 'DELETE';
  new: any;
  old: any;
  timestamp: number;
  diff?: any; // Pour les √©v√©nements UPDATE avec diff
}

/**
 * Hook pour d√©marrer les souscriptions Supabase Realtime
 */
export function useSupabaseRealtime() {
  const [isConnected, setIsConnected] = useState(false);
  const initialized = useRef(false);

  useEffect(() => {
    // TOUT EST COMMENT√â POUR D√âSACTIVER LE REALTIME
    // if (initialized.current) {
    //   return;
    // }
    // logger.dev('[REALTIME] üöÄ D√©marrage des souscriptions Supabase Realtime...');
    // const setupRealtime = async () => {
    //   try {
    //     logger.dev('[REALTIME] üîê Authentification anonyme...');
    //     const { data: { user }, error: authError } = await supabase.auth.getUser();
    //     if (!user) {
    //       logger.dev('[REALTIME] üîê Cr√©ation session anonyme...');
    //       const { data, error } = await supabase.auth.signInAnonymously();
    //       if (error) {
    //         logger.dev('[REALTIME] ‚ö†Ô∏è Erreur auth anonyme:', error.message);
    //       } else {
    //         logger.dev('[REALTIME] ‚úÖ Session anonyme cr√©√©e');
    //       }
    //     } else {
    //       logger.dev('[REALTIME] ‚úÖ Utilisateur d√©j√† authentifi√©:', user.id);
    //     }
    //     initialized.current = true;
    //     logger.dev('[REALTIME] üöÄ D√©marrage des souscriptions...');
    //     subscribeToNotes();
    //     subscribeToDossiers();
    //     subscribeToClasseurs();
    //     startSubscriptionMonitoring();
    //     setIsConnected(true);
    //   } catch (error) {
    //     logger.error('[REALTIME] ‚ùå Erreur lors de l\'activation des souscriptions realtime:', error);
    //     setTimeout(setupRealtime, 3000);
    //   }
    // };
    // setTimeout(setupRealtime, 2000);
    // return () => {
    //   logger.dev('[REALTIME] üõë Arr√™t des souscriptions...');
    //   unsubscribeFromAll();
    //   setIsConnected(false);
    //   initialized.current = false;
    // };
  }, []);

  return { isConnected };
}

/**
 * useRealtime - Hook universel pour le realtime (polling, websocket, sse)
 *
 * @param config {RealtimeConfig}
 *   - type: 'polling' | 'websocket' | 'sse'
 *   - userId: string (pour polling)
 *   - wsUrl: string (pour websocket)
 *   - token: string (pour websocket s√©curis√©)
 *   - debug: boolean (logs)
 *   - onError: (err) => void (callback erreur)
 *   - onEvent: (event: { type, payload, timestamp }) => void (callback g√©n√©rique WS)
 *
 * @returns { subscribe, unsubscribe, subscribeToTables, unsubscribeFromTables }
 *
 * Exemple d'utilisation (WebSocket) :
 *
 *   const { subscribe, unsubscribe } = useRealtime({
 *     type: 'websocket',
 *     wsUrl: 'wss://mon-backend/ws',
 *     token: monTokenJWT,
 *     debug: true,
 *     onEvent: (event) => {
 *       if (event.type === 'note.created') {
 *         // Ajoute la note dans le state local
 *       }
 *     }
 *   });
 *
 *   useEffect(() => {
 *     // ...
 *   }, []);
 */
export function useRealtime(config: RealtimeConfig) {
  const initialized = useRef(false);
  const listeners = useRef<Map<string, (event: ChangeEvent) => void>>(new Map());

  const REALTIME_PROVIDER = process.env.NEXT_PUBLIC_REALTIME_PROVIDER || 'websocket';
  const isSupabase = REALTIME_PROVIDER === 'supabase';
  // üöß Temp: Authentification non impl√©ment√©e
  // TODO: Remplacer USER_ID par l'authentification Supabase

  // Handler g√©n√©rique pour tous les events WebSocket/Supabase
  useEffect(() => {
    if (config.type !== 'websocket' || !config.onEvent) return;
    
    // üöß Temp: Authentification non impl√©ment√©e
    // TODO: Remplacer USER_ID par l'authentification Supabase
    // TODO: Affiner le typage de subscribeToWebSocket pour g√©rer le cas sp√©cifique de la table 'all'
    if (isSupabase) {
      // Supabase realtime service does not have a direct subscribe method for tables
      // This is a placeholder for future implementation if needed
      logger.warn('Supabase realtime service does not support direct table subscription. Consider using a different provider or implementing a custom solution.');
    } else {
      // WebSocket realtime service does not have a direct subscribe method for tables
      // This is a placeholder for future implementation if needed
      logger.warn('WebSocket realtime service does not support direct table subscription. Consider using a different provider or implementing a custom solution.');
    }
  }, [config.type, config.token, config.onEvent, config.debug]);

  useEffect(() => {
    if (initialized.current) return;
    try {
      switch (config.type) {
        case 'polling':
          if (!config.userId) {
            const fallbackUserId = process.env.NEXT_PUBLIC_FALLBACK_USER_ID;
            if (!fallbackUserId) {
              logApi('realtime', 'Aucun userId fourni et aucun fallback configur√©');
              throw new Error('userId requis pour le polling');
            }
            logApi('realtime', `Utilisation du fallback userId: ${fallbackUserId}`);
            initRealtimeService(fallbackUserId);
          } else {
            logApi('realtime', `Initialisation polling avec userId: ${config.userId}`);
            initRealtimeService(config.userId);
          }
          break;
        case 'websocket':
          if (isSupabase) {
            // Pas d'init requis pour supabaseRealtimeService
          } else {
            if (!config.wsUrl || !config.token) throw new Error('wsUrl et token requis pour WebSocket');
            // initWebSocketService(config.wsUrl, config.token, !!config.debug, config.onError); // ANCIEN SYST√àME D√âSACTIV√â
          }
          break;
        case 'sse':
          // √Ä impl√©menter si besoin
          break;
        default:
          throw new Error(`Type de realtime non support√©: ${config.type}`);
      }
      initialized.current = true;
      if (config.debug) logger.dev(`üîÑ Service realtime initialis√© (${config.type})`);
    } catch (error) {
      if (config.debug) logger.error('‚ùå Erreur initialisation realtime:', error);
      if (config.onError) config.onError(error);
    }
    // Cleanup
    return () => {
      try {
        switch (config.type) {
          case 'polling':
            stopRealtimeService(); // ANCIEN SYST√àME D√âSACTIV√â
            break;
          case 'websocket':
            if (isSupabase) {
              // Pas de stop pour supabaseRealtimeService
            } else {
              // stopWebSocketService(); // ANCIEN SYST√àME D√âSACTIV√â
            }
            break;
          case 'sse':
            // √Ä impl√©menter si besoin
            break;
        }
        initialized.current = false;
      } catch (error) {
        if (config.debug) logger.error('‚ùå Erreur cleanup realtime:', error);
        if (config.onError) config.onError(error);
      }
    };
  }, [config.type, config.userId, config.wsUrl, config.token, config.debug, config.onError]);

  /**
   * S'abonner aux changements d'une table
   */
  const subscribe = (table: string, callback: (event: ChangeEvent) => void) => {
    listeners.current.set(table, callback);
    // ANCIEN SYST√àME D√âSACTIV√â - Utilisation du nouveau syst√®me realtime
    // logger.dev(`[useRealtime] üö´ Ancien syst√®me realtime d√©sactiv√© pour ${table} - Utilisation du nouveau syst√®me`);
    
    if (config.type === 'polling') {
      subscribeToPolling(table, callback);
    }
  };

  /**
   * Se d√©sabonner des changements
   */
  const unsubscribe = (table: string, callback: (event: ChangeEvent) => void) => {
    listeners.current.delete(table);
    // ANCIEN SYST√àME D√âSACTIV√â - Utilisation du nouveau syst√®me realtime
    // logger.dev(`[useRealtime] üö´ Ancien syst√®me realtime d√©sactiv√© pour ${table} - Utilisation du nouveau syst√®me`);
    
    if (config.type === 'polling') {
      unsubscribeFromPolling(table, callback);
    }
  };

  /**
   * S'abonner √† plusieurs tables
   */
  const subscribeToTables = (tables: string[], _callback: (event: ChangeEvent) => void) => {
    tables.forEach(table => {
              subscribe(table, _callback);
    });
  };

  /**
   * Se d√©sabonner de plusieurs tables
   */
  const unsubscribeFromTables = (tables: string[], _callback: (event: ChangeEvent) => void) => {
    tables.forEach(table => {
              unsubscribe(table, _callback);
    });
  };

  return {
    subscribe,
    unsubscribe,
    subscribeToTables,
    unsubscribeFromTables,
  };
}

/**
 * Hook sp√©cialis√© pour les notes (remplace l'ancien realtime)
 */
export function useNoteRealtime(noteId: string, userId: string) {
  const { subscribe, unsubscribe } = useRealtime({
    userId,
    type: 'polling',
    interval: 2000
  });

  useEffect(() => {
    if (!noteId || !userId) return;

    const handleNoteChange = (event: ChangeEvent) => {
      if (event.table === 'articles') {
        switch (event.eventType) {
          case 'UPDATE':
            if (event.new?.id === noteId) {
              if (event.diff) {
                useFileSystemStore.getState().applyDiff(noteId, event.diff);
              } else {
                useFileSystemStore.getState().updateNote(noteId, event.new);
              }
            }
            break;
          case 'DELETE':
            if (event.old?.id === noteId) {
              logger.dev('üóëÔ∏è Note supprim√©e en temps r√©el:', event);
              // Ici vous pouvez d√©clencher une action (rediriger, etc.)
            }
            break;
          case 'INSERT':
            logger.dev('‚ûï Nouvelle note cr√©√©e en temps r√©el:', event);
            // Ici vous pouvez d√©clencher une action (rafra√Æchir la liste, etc.)
            break;
        }
      }
    };

    subscribe('articles', handleNoteChange);

    return () => {
      unsubscribe('articles', handleNoteChange);
    };
  }, [noteId, userId, subscribe, unsubscribe]);

  return { subscribe, unsubscribe };
}

/**
 * Hook sp√©cialis√© pour les dossiers
 */
export function useFolderRealtime(classeurId: string, userId: string) {
  const { subscribe, unsubscribe } = useRealtime({
    userId,
    type: 'polling',
    interval: 3000
  });

  useEffect(() => {
    if (!classeurId || !userId) return;

    const handleFolderChange = (event: ChangeEvent) => {
      if (event.table === 'folders') {
        switch (event.eventType) {
          case 'UPDATE':
            if (event.new?.classeur_id === classeurId) {
              logger.dev('üìÅ Dossier modifi√© en temps r√©el:', event);
              // Ici vous pouvez d√©clencher une action (recharger la liste, etc.)
            }
            break;
          case 'INSERT':
            if (event.new?.classeur_id === classeurId) {
              logger.dev('üìÅ Nouveau dossier cr√©√© en temps r√©el:', event);
              // Ici vous pouvez d√©clencher une action (ajouter √† la liste, etc.)
            }
            break;
          case 'DELETE':
            logger.dev('üóëÔ∏è Dossier supprim√© en temps r√©el:', event);
            // Ici vous pouvez d√©clencher une action (retirer de la liste, etc.)
            break;
        }
      }
    };

    const handleArticleChange = (event: ChangeEvent) => {
      if (event.table === 'articles') {
        switch (event.eventType) {
          case 'UPDATE':
            if (event.new?.classeur_id === classeurId) {
              if (event.diff) {
                useFileSystemStore.getState().applyDiff(event.new.id, event.diff);
              } else {
                useFileSystemStore.getState().updateNote(event.new.id, event.new);
              }
            }
            break;
          case 'INSERT':
            if (event.new?.classeur_id === classeurId) {
              logger.dev('üìÑ Nouvel article cr√©√© en temps r√©el:', event);
              // Ici vous pouvez d√©clencher une action (ajouter √† la liste, etc.)
            }
            break;
          case 'DELETE':
            logger.dev('üóëÔ∏è Article supprim√© en temps r√©el:', event);
            // Ici vous pouvez d√©clencher une action (retirer de la liste, etc.)
            break;
        }
      }
    };

    subscribe('folders', handleFolderChange);
    subscribe('articles', handleArticleChange);

    return () => {
      unsubscribe('folders', handleFolderChange);
      unsubscribe('articles', handleArticleChange);
    };
  }, [classeurId, userId, subscribe, unsubscribe]);

  return { subscribe, unsubscribe };
} 