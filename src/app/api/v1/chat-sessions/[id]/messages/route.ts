import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { z } from 'zod';
import { simpleLogger as logger } from '@/utils/logger';

// Configuration Supabase
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

logger.dev('[Chat Messages API] üîß Configuration:', {
  supabaseUrl: supabaseUrl ? '‚úÖ Configur√©' : '‚ùå Manquant',
  supabaseKey: supabaseKey ? '‚úÖ Configur√©' : '‚ùå Manquant'
});

if (!supabaseUrl || !supabaseKey) {
  logger.error('[Chat Messages API] ‚ùå Variables d\'environnement Supabase manquantes');
  throw new Error('Configuration Supabase manquante');
}

// Client avec service role pour les op√©rations admin
const supabaseAdmin = createClient(supabaseUrl, supabaseKey);

// Sch√©ma de validation pour ajouter un message
const addMessageSchema = z.object({
  role: z.enum(['user', 'assistant', 'system', 'tool']),
  content: z.string().nullable().optional(),
  timestamp: z.string().optional().default(() => new Date().toISOString()),
  // Support pour les tool calls (format DeepSeek)
  tool_calls: z.array(z.object({
    id: z.string(),
    type: z.literal('function'),
    function: z.object({
      name: z.string(),
      arguments: z.string()
    })
  })).optional(),
  tool_call_id: z.string().optional(), // Pour les messages tool
  name: z.string().optional() // üîß CORRECTION: Ajouter le name pour les messages tool
});

// POST /api/v1/chat-sessions/[id]/messages - Ajouter un message √† une session
export async function POST(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    logger.dev('[Chat Messages API] üìù Ajout de message √† la session:', id);
    
    // R√©cup√©rer l'utilisateur depuis l'en-t√™te d'autorisation
    const authHeader = request.headers.get('authorization');
    let userId: string;
    let userToken: string;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      // Token JWT fourni
      userToken = authHeader.substring(7);
      const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(userToken);
      
      if (authError || !user) {
        logger.error('[Chat Messages API] ‚ùå Erreur auth:', authError);
        return NextResponse.json(
          { error: 'Token invalide ou expir√©' },
          { status: 401 }
        );
      }
      userId = user.id;
    } else {
      return NextResponse.json(
        { error: 'Authentification requise' },
        { status: 401 }
      );
    }

    const sessionId = id;
    const body = await request.json();
    const validatedData = addMessageSchema.parse(body);

    logger.dev('[Chat Messages API] üìã Donn√©es re√ßues:', validatedData);

    // Cr√©er le nouveau message
    const newMessage = {
      id: crypto.randomUUID(),
      role: validatedData.role,
      content: validatedData.content,
      timestamp: validatedData.timestamp,
      tool_calls: validatedData.tool_calls,
      tool_call_id: validatedData.tool_call_id,
      name: validatedData.name // üîß CORRECTION: Inclure le name pour les messages tool
    };

    // Cr√©er un client avec le contexte d'authentification de l'utilisateur
    const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
    if (!anonKey) {
      throw new Error('NEXT_PUBLIC_SUPABASE_ANON_KEY manquante');
    }
    
    const userClient = createClient(supabaseUrl!, anonKey, {
      global: {
        headers: {
          Authorization: `Bearer ${userToken}`
        }
      }
    });

    // R√©cup√©rer la session actuelle avec le contexte utilisateur
    logger.dev('[Chat Messages API] üîç Recherche session:', sessionId);
    const { data: currentSession, error: fetchError } = await userClient
      .from('chat_sessions')
      .select('thread, history_limit')
      .eq('id', sessionId)
      .single();

    if (fetchError) {
      if (fetchError.code === 'PGRST116') {
        logger.error('[Chat Messages API] ‚ùå Session non trouv√©e:', sessionId);
        return NextResponse.json(
          { error: 'Session non trouv√©e' },
          { status: 404 }
        );
      }
      
      logger.error('[Chat Messages API] ‚ùå Erreur r√©cup√©ration session:', fetchError);
      return NextResponse.json(
        { error: 'Erreur lors de la r√©cup√©ration de la session' },
        { status: 500 }
      );
    }

    // Ajouter le nouveau message au thread
    const currentThread = currentSession.thread || [];
    const updatedThread = [...currentThread, newMessage];

    // Appliquer la limite d'historique
    const historyLimit = currentSession.history_limit || 10;
    const limitedThread = updatedThread.slice(-historyLimit);

    logger.dev('[Chat Messages API] üíæ Mise √† jour du thread...', {
      ancienThread: currentThread.length,
      nouveauThread: updatedThread.length,
      threadLimit√©: limitedThread.length,
      limite: historyLimit
    });

    // Mettre √† jour la session avec le nouveau thread limit√©
    const { data: updatedSession, error: updateError } = await userClient
      .from('chat_sessions')
      .update({ 
        thread: limitedThread,
        updated_at: new Date().toISOString()
      })
      .eq('id', sessionId)
      .select()
      .single();

    if (updateError) {
      logger.error('[Chat Messages API] ‚ùå Erreur mise √† jour session:', updateError);
      return NextResponse.json(
        { error: 'Erreur lors de la mise √† jour de la session' },
        { status: 500 }
      );
    }

    logger.dev('[Chat Messages API] ‚úÖ Message ajout√© avec succ√®s');

    return NextResponse.json({
      success: true,
      data: {
        session: updatedSession,
        message: newMessage
      }
    }, { status: 201 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.error('[Chat Messages API] ‚ùå Erreur validation:', error.errors);
      return NextResponse.json(
        { error: 'Donn√©es invalides', details: error.errors },
        { status: 400 }
      );
    }

    logger.error('[Chat Messages API] ‚ùå Erreur serveur:', error);
    return NextResponse.json(
      { error: 'Erreur serveur interne' },
      { status: 500 }
    );
  }
}

// GET /api/v1/chat-sessions/[id]/messages - R√©cup√©rer les messages d'une session
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await context.params;
    
    // R√©cup√©rer l'utilisateur depuis l'en-t√™te d'autorisation
    const authHeader = request.headers.get('authorization');
    let userToken: string;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      userToken = authHeader.substring(7);
    } else {
      return NextResponse.json(
        { error: 'Authentification requise' },
        { status: 401 }
      );
    }

    // Cr√©er un client avec le contexte d'authentification de l'utilisateur
    const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
    if (!anonKey) {
      throw new Error('NEXT_PUBLIC_SUPABASE_ANON_KEY manquante');
    }
    
    const userClient = createClient(supabaseUrl!, anonKey, {
      global: {
        headers: {
          Authorization: `Bearer ${userToken}`
        }
      }
    });

    const sessionId = id;

    // R√©cup√©rer la session avec son thread
    const { data: session, error } = await userClient
      .from('chat_sessions')
      .select('thread')
      .eq('id', sessionId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json(
          { success: false, error: 'Session non trouv√©e' },
          { status: 404 }
        );
      }
      
      logger.error('Erreur lors de la r√©cup√©ration des messages:', error);
      return NextResponse.json(
        { success: false, error: 'Erreur lors de la r√©cup√©ration des messages' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        messages: session.thread || []
      }
    });

  } catch (error) {
    logger.error('Erreur serveur:', error);
    return NextResponse.json(
      { success: false, error: 'Erreur serveur interne' },
      { status: 500 }
    );
  }
} 