# üìò Guide OpenAPI - Synesia Schemas

**Date de cr√©ation** : 2 octobre 2025  
**Auteur** : Agent Synesia (Claude Sonnet 4.5)  
**Objectif** : Documentation des erreurs rencontr√©es et bonnes pratiques pour la cr√©ation de sch√©mas OpenAPI

---

## üéØ Contexte

Ce document r√©f√©rence les erreurs rencontr√©es lors de la cr√©ation initiale des sch√©mas OpenAPI pour l'API Synesia, ainsi que les solutions et recommandations pour les agents IA futurs.

---

## üêõ Erreurs Rencontr√©es et Solutions

### Erreur 1 : Responses en Array au lieu d'Objet

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üî¥ Critique  
**Source** : Bug MCP Factoria (maintenant corrig√©)

#### ‚ùå Sympt√¥me
```
Error: 'list' object has no attribute 'keys'
Error: Failed to parse OpenAPI spec
```

#### üîç Cause
Le MCP Factoria acceptait les responses en format array (pratique pour les IA) mais ne les convertissait pas correctement en format OpenAPI standard.

#### ‚ùå Format incorrect (array)
```json
{
  "responses": [
    {"status": 200, "description": "Success"},
    {"status": 400, "description": "Bad Request"}
  ]
}
```

#### ‚úÖ Format correct (objet)
```json
{
  "responses": {
    "200": {"description": "Success"},
    "400": {"description": "Bad Request"}
  }
}
```

#### üõ†Ô∏è Solution
- ‚úÖ Bug corrig√© dans le MCP Factoria le 2 octobre 2025
- ‚úÖ Le MCP convertit maintenant automatiquement array ‚Üí objet
- ‚úÖ Accepte √† la fois `status` et `statusCode` (num√©rique ou string)

#### üìù Note pour l'agent futur
Lorsque tu utilises le MCP Factoria, tu peux passer les responses en array (c'est plus pratique), il g√©rera la conversion. Mais si tu √©dites le JSON directement, utilise **toujours** le format objet.

---

### Erreur 2 : Array sans propri√©t√© `items`

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü† Moyenne  
**Source** : ‚ùå Erreur de l'agent IA (moi)

#### ‚ùå Sympt√¥me
```
Error: array schema missing items
In context: (..., 'properties', 'value', 'oneOf', '4')
```

#### üîç Cause
En OpenAPI 3.x, **tout** sch√©ma de type `array` DOIT avoir une propri√©t√© `items` qui d√©finit le type des √©l√©ments.

#### ‚ùå Format incorrect
```json
{
  "type": "array"
}
```

#### ‚úÖ Format correct
```json
{
  "type": "array",
  "items": {}  // Accepte n'importe quel type
}
```

```json
{
  "type": "array",
  "items": {
    "type": "string"  // Tableau de strings uniquement
  }
}
```

#### üìù Note pour l'agent futur
**TOUJOURS** ajouter `items` pour les arrays, m√™me si c'est `{}` (accepte tout). Ne jamais laisser un `"type": "array"` seul.

---

### Erreur 3 : Section `security` globale manquante

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü° Faible (mais bloque certains parsers)  
**Source** : ‚ùå Erreur de l'agent IA (moi)

#### ‚ùå Sympt√¥me
```
Error: Cannot parse OpenAPI spec
Factoria ne d√©tecte pas l'authentification
```

#### üîç Cause
Certains outils (dont Factoria, ChatGPT, Swagger UI) s'attendent √† une d√©claration de s√©curit√© au niveau racine, m√™me si chaque endpoint d√©clare individuellement sa s√©curit√©.

#### ‚ùå Format incomplet
```json
{
  "openapi": "3.1.0",
  "info": {...},
  "servers": [...],
  // ‚Üê Manque "security" ici
  "components": {
    "securitySchemes": {...}
  },
  "paths": {
    "/endpoint": {
      "get": {
        "security": [{"ApiKeyAuth": []}]  // ‚Üê D√©clar√© uniquement ici
      }
    }
  }
}
```

#### ‚úÖ Format complet
```json
{
  "openapi": "3.1.0",
  "info": {...},
  "servers": [...],
  "security": [              // ‚Üê S√©curit√© globale (d√©faut)
    {"ApiKeyAuth": []}
  ],
  "components": {
    "securitySchemes": {...}
  },
  "paths": {
    "/endpoint": {
      "get": {
        "security": [{"ApiKeyAuth": []}]  // ‚Üê Optionnel si global existe
      }
    }
  }
}
```

#### üìù Note pour l'agent futur
**TOUJOURS** d√©clarer `security` au niveau racine juste apr√®s `servers`. Cela d√©finit la s√©curit√© par d√©faut pour toute l'API.

---

### Erreur 4 : `components.schemas` manquant

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü° Faible  
**Source** : ‚ùå Erreur de l'agent IA (moi)

#### ‚ùå Sympt√¥me
```
Error: In components section, schemas subsection is not an object
```

#### üîç Cause
La section `components` doit contenir des sous-sections qui sont des **objets**, m√™me vides.

#### ‚ùå Format incorrect
```json
{
  "components": {
    "securitySchemes": {...}
    // ‚Üê Manque "schemas"
  }
}
```

#### ‚úÖ Format correct
```json
{
  "components": {
    "schemas": {},  // ‚Üê Obligatoire, m√™me vide
    "securitySchemes": {...}
  }
}
```

#### üìù Note pour l'agent futur
Toujours initialiser `components.schemas` √† `{}` au minimum. C'est l√† que tu stockeras les sch√©mas r√©utilisables avec `$ref`.

---

## ‚úÖ Checklist Compl√®te OpenAPI 3.1.0

Utilise cette checklist pour **chaque nouveau sch√©ma** :

### üìã Structure de base (ordre recommand√©)

```json
{
  "openapi": "3.1.0",                    // ‚úÖ Version
  "info": {                              // ‚úÖ M√©tadonn√©es
    "title": "...",
    "version": "1.0.0",
    "description": "..."
  },
  "servers": [                           // ‚úÖ Serveurs
    {"url": "https://api.synesia.app"}
  ],
  "security": [                          // ‚úÖ S√©curit√© globale
    {"ApiKeyAuth": []}
  ],
  "components": {                        // ‚úÖ Composants r√©utilisables
    "schemas": {},                       // ‚úÖ TOUJOURS pr√©sent (m√™me vide)
    "securitySchemes": {                 // ‚úÖ D√©finition de la s√©curit√©
      "ApiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "Format: ApiKey apiKey.{id}.{key}"
      }
    }
  },
  "paths": {                             // ‚úÖ Endpoints
    "/endpoint": {
      "get": {
        "tags": ["..."],
        "summary": "...",
        "description": "...",
        "operationId": "...",
        "security": [{"ApiKeyAuth": []}], // ‚úÖ Par endpoint (optionnel si global d√©fini)
        "parameters": [],
        "requestBody": {...},
        "responses": {                    // ‚úÖ OBJET, pas array !
          "200": {...},                   // ‚úÖ String, pas number
          "400": {...}
        }
      }
    }
  }
}
```

### üî• Points critiques √† v√©rifier

| ‚úÖ | √âl√©ment | V√©rification |
|----|---------|--------------|
| ‚òëÔ∏è | `responses` | Est-ce un **objet** ? Codes HTTP en **string** ? |
| ‚òëÔ∏è | Arrays | Chaque `"type": "array"` a-t-il `"items"` ? |
| ‚òëÔ∏è | Objects | Chaque `"type": "object"` a-t-il `"properties"` (m√™me vide) ? |
| ‚òëÔ∏è | `security` global | D√©clar√© apr√®s `servers` ? |
| ‚òëÔ∏è | `components.schemas` | Existe-t-il (m√™me vide) ? |
| ‚òëÔ∏è | `$ref` | Pointe vers `#/components/schemas/...` ? |
| ‚òëÔ∏è | Headers | Document√©s dans description (pas comme param√®tres) ? |
| ‚òëÔ∏è | `oneOf/anyOf` | Utilis√© uniquement quand n√©cessaire ? |

---

## ü§ñ Prompting pour l'Agent Futur Sp√©cialis√©

### Prompt d'initialisation

```markdown
Tu es un agent sp√©cialis√© dans la cr√©ation de sch√©mas OpenAPI 3.1.0 pour l'API Synesia.

R√àGLES STRICTES :

1. **Structure JSON** :
   - `responses` DOIT √™tre un OBJET avec codes HTTP en STRING : {"200": {...}, "400": {...}}
   - JAMAIS un array : [{"status": 200, ...}]
   - Codes HTTP toujours en string : "200" pas 200

2. **Arrays** :
   - Tout sch√©ma avec "type": "array" DOIT avoir "items"
   - Minimum : {"type": "array", "items": {}}
   - Sp√©cifique : {"type": "array", "items": {"type": "string"}}

3. **Objects** :
   - Tout sch√©ma avec "type": "object" DOIT avoir "properties"
   - Minimum : {"type": "object", "properties": {}}
   - M√™me si tu utilises "additionalProperties": true

4. **S√©curit√©** :
   - Toujours d√©clarer "security" au niveau racine apr√®s "servers"
   - Format : "security": [{"ApiKeyAuth": []}] ou [] pour public
   - Utiliser le sch√©ma ApiKeyAuth de Synesia

5. **Descriptions** :
   - LIMITE : 300 caract√®res maximum
   - √ätre concis et pr√©cis
   - D√©tails suppl√©mentaires ‚Üí section x-synesia

6. **RequestBody** :
   - ChatGPT exige "type": "object" (pas oneOf √† la racine)
   - Pour payloads flexibles : type object + additionalProperties: true
   - Diff√©rencier via examples, pas oneOf

7. **Components** :
   - Toujours inclure "schemas": {} dans components (m√™me vide)
   - Cr√©er des sch√©mas r√©utilisables pour √©viter la duplication
   - Utiliser $ref pour r√©f√©rencer : "#/components/schemas/NomSchema"

8. **Ordre de structure** :
   openapi ‚Üí info ‚Üí servers ‚Üí security ‚Üí components ‚Üí paths

9. **Validation** :
   - V√©rifier la structure avec un validateur OpenAPI avant de livrer
   - Tester le sch√©ma dans Swagger Editor
   - S'assurer qu'il est parsable par ChatGPT et Factoria

AUTHENTIFICATION SYNESIA :
- Type: apiKey
- Header: Authorization
- Format: "ApiKey apiKey.{id}.{key}"

ENDPOINTS PUBLICS (sans auth) :
- /webhooks/{id} - Utiliser security: [] pour override

EXEMPLES √Ä INCLURE :
- Toujours fournir des exemples concrets pour requestBody
- Toujours fournir des exemples de r√©ponses (success et error)
- Utiliser des donn√©es r√©alistes de Synesia
```

### Prompt de v√©rification pr√©-livraison

```markdown
Avant de livrer un sch√©ma OpenAPI, V√âRIFIER :

‚úÖ Structure :
   - [ ] "openapi": "3.1.0" pr√©sent ?
   - [ ] "security" global d√©clar√© apr√®s "servers" ?
   - [ ] "components.schemas" existe (m√™me vide) ?

‚úÖ Responses :
   - [ ] Chaque endpoint a "responses" en OBJET ?
   - [ ] Codes HTTP en STRING ("200" pas 200) ?
   - [ ] Inclut 200, 400, 401 au minimum ?

‚úÖ Arrays :
   - [ ] Chaque "type": "array" a "items" ?
   - [ ] Items d√©fini correctement ?

‚úÖ S√©curit√© :
   - [ ] ApiKeyAuth d√©fini dans securitySchemes ?
   - [ ] Format Synesia document√© ?

‚úÖ Qualit√© :
   - [ ] Descriptions claires et compl√®tes ?
   - [ ] Exemples r√©alistes fournis ?
   - [ ] Tags coh√©rents pour regrouper ?

Si TOUTES les cases sont coch√©es ‚Üí Livrer
Sinon ‚Üí Corriger avant de livrer
```

### Prompt de cr√©ation d'endpoint

```markdown
Quand tu ajoutes un endpoint, UTILISER CE TEMPLATE :

{
  "paths": {
    "/votre-endpoint": {
      "post": {
        "tags": ["Cat√©gorie"],
        "summary": "Description courte",
        "description": "Description d√©taill√©e du comportement",
        "operationId": "operation_unique_id",
        "security": [{"ApiKeyAuth": []}],  // ‚Üê NE PAS OUBLIER (sauf endpoints publics)
        "parameters": [],                  // ‚Üê Vide si pas de params
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["champ1"],
                "properties": {
                  "champ1": {
                    "type": "string",
                    "description": "..."
                  },
                  "tableau": {
                    "type": "array",
                    "items": {"type": "string"}  // ‚Üê NE PAS OUBLIER items !
                  }
                }
              },
              "examples": {              // ‚Üê TOUJOURS fournir des exemples
                "exemple1": {
                  "summary": "Cas simple",
                  "value": {...}
                }
              }
            }
          }
        },
        "responses": {                   // ‚Üê OBJET, pas array !
          "200": {                       // ‚Üê String, pas number !
            "description": "Succ√®s",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {...}
                },
                "example": {...}         // ‚Üê Exemple de r√©ponse
              }
            }
          },
          "400": {
            "description": "Requ√™te invalide",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"  // ‚Üê R√©utiliser
                }
              }
            }
          },
          "401": {
            "description": "Authentification invalide",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    }
  }
}
```

---

### Erreur 5 : Object sans `properties`

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü† Moyenne  
**Source** : ‚ùå Erreur de l'agent IA (moi)

#### ‚ùå Sympt√¥me
```
Error: object schema missing properties
In context: ('components', 'schemas', 'GenericWebhookPayload')
```

#### üîç Cause
En OpenAPI 3.x, un sch√©ma de type `object` doit avoir une propri√©t√© `properties`, m√™me si elle est vide. L'utilisation de `additionalProperties: true` seul n'est pas suffisante.

#### ‚ùå Format incorrect
```json
{
  "type": "object",
  "additionalProperties": true
}
```

#### ‚úÖ Format correct
```json
{
  "type": "object",
  "properties": {},  // ‚Üê Obligatoire, m√™me vide
  "additionalProperties": true
}
```

#### üìù Note pour l'agent futur
**TOUJOURS** ajouter `properties: {}` pour les objets, m√™me si tu utilises `additionalProperties: true` pour accepter n'importe quelle propri√©t√©. C'est une exigence stricte d'OpenAPI.

---

### Erreur 6 : Headers document√©s comme param√®tres

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü° Faible (warning, pas bloquant)  
**Source** : ‚ö†Ô∏è Limitation du parser

#### ‚ùå Sympt√¥me
```
Warning: parameter x-signature-ed25519 has location header; ignoring
Warning: parameter x-signature-timestamp has location header; ignoring
```

#### üîç Cause
Certains parsers (dont ChatGPT) n'acceptent pas les headers comme param√®tres dans la section `parameters`. Ils s'attendent √† les voir dans `components/parameters` ou document√©s ailleurs.

#### ‚ùå Format probl√©matique
```json
{
  "parameters": [
    {
      "name": "x-signature-ed25519",
      "in": "header",
      "required": false,
      "schema": {"type": "string"}
    }
  ]
}
```

#### ‚úÖ Format recommand√©
Documenter les headers dans la **description** de l'endpoint :

```json
{
  "description": "Point d'entr√©e webhook.\n\n**Headers optionnels Discord** :\n- `x-signature-ed25519` : Signature\n- `x-signature-timestamp` : Timestamp"
}
```

Ou utiliser `components/parameters` (plus complexe) :
```json
{
  "components": {
    "parameters": {
      "DiscordSignature": {
        "name": "x-signature-ed25519",
        "in": "header",
        "schema": {"type": "string"}
      }
    }
  }
}
```

#### üìù Note pour l'agent futur
Pour les headers **optionnels** de v√©rification (Discord, Slack), pr√©f√®re les documenter dans la description plut√¥t que comme param√®tres. √áa √©vite les warnings et c'est plus lisible.

---

### Erreur 7 : Description trop longue

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü° Faible  
**Source** : ‚ö†Ô∏è Limitation ChatGPT/Factoria

#### ‚ùå Sympt√¥me
```
Error: description has length 352 exceeding limit of 300
```

#### üîç Cause
ChatGPT et certains parsers limitent la longueur des descriptions √† **300 caract√®res maximum**.

#### ‚ùå Format probl√©matique
```json
{
  "description": "Point d'entr√©e public pour recevoir des webhooks depuis des services tiers. G√®re automatiquement les v√©rifications sp√©cifiques (Discord ping, Slack challenge, etc.) et ex√©cute le pipeline configur√©.\n\nHeaders optionnels Discord :\n- x-signature-ed25519 : Signature de v√©rification Discord\n- x-signature-timestamp : Timestamp de la requ√™te Discord"
}
```
**(352 caract√®res - trop long !)**

#### ‚úÖ Format correct
```json
{
  "description": "Point d'entr√©e public pour webhooks tiers (Discord, Slack, custom). G√®re automatiquement les v√©rifications (ping, challenge) et ex√©cute le pipeline configur√©."
}
```
**(< 300 caract√®res)**

#### üìù Note pour l'agent futur
- **Limite stricte** : 300 caract√®res pour les descriptions
- **Si plus de d√©tails n√©cessaires** : Utiliser la section `x-synesia` pour notes techniques
- **Headers/d√©tails** : Mettre dans des exemples ou documentation externe
- **Astuce** : Compter les caract√®res avant de valider : `description.length <= 300`

---

### Erreur 8 : oneOf directement dans requestBody

**Date** : 2 octobre 2025  
**S√©v√©rit√©** : üü† Moyenne  
**Source** : ‚ö†Ô∏è Limitation du parser

#### ‚ùå Sympt√¥me
```
Error: request body schema is not an object schema; skipping
Error: skipping function due to errors
```

#### üîç Cause
ChatGPT s'attend √† ce que le schema du requestBody soit un objet avec `type: "object"`. L'utilisation de `oneOf` directement √† la racine pose probl√®me.

#### ‚ùå Format probl√©matique
```json
{
  "requestBody": {
    "content": {
      "application/json": {
        "schema": {
          "oneOf": [
            {"$ref": "#/components/schemas/TypeA"},
            {"$ref": "#/components/schemas/TypeB"}
          ]
        }
      }
    }
  }
}
```

#### ‚úÖ Format correct
Pour un payload **flexible** (comme les webhooks), utiliser un objet g√©n√©rique :

```json
{
  "requestBody": {
    "content": {
      "application/json": {
        "schema": {
          "type": "object",
          "properties": {},
          "additionalProperties": true
        },
        "examples": {
          "typeA": {...},
          "typeB": {...}
        }
      }
    }
  }
}
```

Ou si tu veux vraiment discriminer les types, utiliser un wrapper :

```json
{
  "schema": {
    "type": "object",
    "properties": {
      "payload": {
        "oneOf": [...]
      }
    }
  }
}
```

#### üìù Note pour l'agent futur
- **ChatGPT n'aime pas `oneOf` √† la racine du requestBody**
- Pour des payloads **flexibles** (webhooks, etc.) : Utiliser `type: object` avec `additionalProperties: true`
- **Diff√©rencier les cas** via les `examples`, pas via `oneOf`
- Les exemples sont souvent plus utiles que oneOf pour les APIs flexibles

---

## üìö Bonnes Pratiques Synesia

### 1. Sch√©mas R√©utilisables (DRY)

Cr√©er des sch√©mas dans `components/schemas` pour √©viter la duplication :

```json
{
  "components": {
    "schemas": {
      "ErrorResponse": {
        "type": "object",
        "required": ["data", "error"],
        "properties": {
          "data": {"type": "null"},
          "error": {"type": "string"}
        }
      },
      "SuccessResponse": {
        "type": "object",
        "required": ["data", "error"],
        "properties": {
          "data": {},
          "error": {"type": "null"}
        }
      }
    }
  }
}
```

Puis les r√©f√©rencer :
```json
{
  "responses": {
    "400": {
      "description": "Erreur",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/ErrorResponse"
          }
        }
      }
    }
  }
}
```

### 2. Format de R√©ponse Standard Synesia

La plupart des endpoints Synesia retournent ce format :

```json
{
  "data": <r√©sultat ou null>,
  "error": <message d'erreur ou null>
}
```

Utiliser les sch√©mas `SuccessResponse` et `ErrorResponse` pour coh√©rence.

### 3. Authentification ApiKey

**Format standard Synesia** :
```
Authorization: ApiKey apiKey.{id}.{key}
```

**D√©finition dans le sch√©ma** :
```json
{
  "components": {
    "securitySchemes": {
      "ApiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "Authentification par cl√© API. Format: ApiKey apiKey.{id}.{key}"
      }
    }
  }
}
```

**Application globale** :
```json
{
  "security": [
    {"ApiKeyAuth": []}
  ]
}
```

**Override pour endpoints publics** :
```json
{
  "paths": {
    "/endpoint-public": {
      "post": {
        "security": []  // ‚Üê Vide = pas d'auth du tout
      }
    }
  }
}
```

**Authentification OPTIONNELLE** (webhooks configurables) :
```json
{
  "paths": {
    "/webhooks/{id}": {
      "post": {
        "security": [
          {"ApiKeyAuth": []},  // ‚Üê Option 1: Avec ApiKey
          {}                   // ‚Üê Option 2: Sans auth (public)
        ]
      }
    }
  }
}
```

Ce pattern dit : "Cet endpoint peut √™tre appel√© **soit** avec ApiKey, **soit** sans authentification". Parfait pour les webhooks Synesia o√π l'auth est configurable !

### 4. Param√®tres dans le Path

Quand un param√®tre est dans l'URL, utiliser `{param}` et le d√©clarer :

```json
{
  "paths": {
    "/kv-storages/{id}/entries/{key}": {
      "get": {
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,  // ‚Üê TOUJOURS true pour les path params
            "schema": {"type": "string"},
            "description": "ID du KV storage"
          },
          {
            "name": "key",
            "in": "path",
            "required": true,
            "schema": {"type": "string"},
            "description": "Cl√© de l'entr√©e (URL-encoded)"
          }
        ]
      }
    }
  }
}
```

### 5. Query Parameters

```json
{
  "parameters": [
    {
      "name": "wait",
      "in": "query",
      "required": false,  // ‚Üê Peut √™tre false pour query params
      "schema": {
        "type": "string",
        "enum": ["true", "false"],
        "default": "false"
      },
      "description": "Attendre la fin de l'ex√©cution"
    }
  ]
}
```

### 6. Types Flexibles (oneOf)

Pour accepter plusieurs types (KV storage par exemple) :

```json
{
  "value": {
    "description": "Peut √™tre string, number, object, array, boolean",
    "oneOf": [
      {"type": "string"},
      {"type": "number"},
      {"type": "boolean"},
      {"type": "object"},
      {"type": "array", "items": {}}  // ‚Üê NE PAS OUBLIER items !
    ]
  }
}
```

### 7. Exemples Multiples

Toujours fournir plusieurs exemples pour montrer les cas d'usage :

```json
{
  "examples": {
    "simple": {
      "summary": "Cas simple",
      "value": {...}
    },
    "complex": {
      "summary": "Cas complexe avec options",
      "value": {...}
    },
    "error": {
      "summary": "Cas d'erreur",
      "value": {...}
    }
  }
}
```

---

## üé® Conventions de Nommage

### operationId
**Format** : `verbe__chemin_avec_underscores`

| Route | M√©thode | operationId |
|-------|---------|-------------|
| `/execution` | POST | `post__execution` |
| `/execution/{id}` | POST | `post__execution__id` |
| `/kv-storages/{id}/entries/{key}` | GET | `get__kv_storages__id__entries__key` |

### Tags
Grouper les endpoints par fonctionnalit√© :

```json
{
  "tags": ["LLM Execution"]     // Pour /llm-exec/*
  "tags": ["Execution"]         // Pour /execution/*
  "tags": ["KV Storage Management"]  // Pour CRUD du storage
  "tags": ["KV Entries"]        // Pour CRUD des entr√©es
  "tags": ["Memory"]            // Pour /memory/*
  "tags": ["Webhooks"]          // Pour /webhooks/*
}
```

---

## üöÄ Workflow Recommand√©

### Pour petits sch√©mas (< 10 endpoints)

1. **Cr√©er un fichier JSON directement**
   ```bash
   touch openapi-schemas/nom-api.json
   ```

2. **Structure de base avec checklist**
   - ‚úÖ openapi, info, servers
   - ‚úÖ security global
   - ‚úÖ components avec schemas: {}
   - ‚úÖ securitySchemes

3. **Ajouter les endpoints un par un**
   - Utiliser le template ci-dessus
   - V√©rifier responses en objet
   - V√©rifier arrays avec items

4. **Valider avant de livrer**
   ```bash
   # Syntaxe JSON
   jq . schema.json
   
   # Validation OpenAPI (si outil disponible)
   npx @apidevtools/swagger-cli validate schema.json
   ```

### Pour gros sch√©mas (50-200+ endpoints)

1. **Utiliser MCP Factoria directement**
   - Cr√©er le sch√©ma : `create_schema`
   - Configurer m√©tadonn√©es : `update_metadata`
   - Ajouter endpoints : `add_endpoint` (maintenant corrig√© !)
   - Valider : `validate_schema`

2. **√âdition granulaire**
   - Lire la map : `read_schema_map_paginated`
   - Focus sur un endpoint : `focus_endpoint`
   - Modifier : `update_endpoint`

3. **Export final**
   - Exporter : `export_schema` (format json)
   - Sauvegarder dans Git
   - Versionner

---

## üîç Outils de Validation

### Avant de livrer un sch√©ma :

1. **Validation syntax JSON**
   ```bash
   jq . schema.json > /dev/null && echo "‚úÖ Valid JSON" || echo "‚ùå Invalid JSON"
   ```

2. **Validation OpenAPI (local)**
   ```bash
   npx @apidevtools/swagger-cli validate schema.json
   ```

3. **Validation en ligne**
   - Swagger Editor : https://editor.swagger.io/
   - Copier-coller le JSON
   - V√©rifier qu'il n'y a aucune erreur

4. **Test avec ChatGPT**
   - Importer le sch√©ma dans une GPT Action
   - Tenter un appel
   - Si erreur de parsing ‚Üí corriger

---

## üìñ Ressources

- [OpenAPI 3.1.0 Specification](https://spec.openapis.org/oas/v3.1.0)
- [Swagger Editor](https://editor.swagger.io/)
- [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)
- [Factoria MCP Documentation](lien vers ta doc si elle existe)

---

## üìù Historique des Sch√©mas Cr√©√©s

| Date | Sch√©ma | Endpoints | Status | Notes |
|------|--------|-----------|--------|-------|
| 2025-12-06 | `llm-tools-tasks.json` | 6 | ‚úÖ Valid√© | API conversationnelle Tasks pour LLMs - Noms d'agents (pas UUIDs), format condens√©, filtres intelligents |
| 2025-12-01 | `llm-exec.json` | 2 | ‚úÖ Valid√© | POST /llm-exec/round, POST /llm-exec/round/stream - RoundLogger, Provider Selection, MCP Tools |
| 2025-10-02 | `execution.json` | 2 | ‚úÖ Valid√© | POST /execution, POST /execution/{callable_id} |
| 2025-10-02 | `kv-storage.json` | 9 | ‚úÖ Valid√© | CRUD KV storage + entries |
| 2025-10-02 | Factoria (execution) | 2 | ‚úÖ Import√© | ID: 8e2a89a6-a47a-4f72-83e9-8c18517b6df7 |
| 2025-10-02 | Factoria (llm-exec) | 2 | ‚úÖ Import√© | ID: 2a3a5420-a7e0-430f-8125-3b4ecaa1d5a3 |

---

## üéì Le√ßons Apprises

### Ce qui a bien fonctionn√© ‚úÖ
- Cr√©er des sch√©mas r√©utilisables dans `components/schemas`
- Utiliser des exemples concrets et multiples
- Structurer par tags pour la navigation
- Valider progressivement pendant la cr√©ation

### Ce qui a pos√© probl√®me ‚ùå
- Oubli de `items` pour les arrays
- Oubli de `security` global
- Format responses en array (bug MCP Factoria, maintenant corrig√©)
- R√©f√©rences `$ref` trop complexes vers paths au lieu de components

### Am√©liorations futures üöÄ
- Cr√©er un template de base r√©utilisable
- Script de validation automatique
- G√©n√©rateur de sch√©mas √† partir du code TypeScript (extraction auto)
- Tests automatis√©s pour valider la compatibilit√©

---

## üí° Recommandations pour l'Agent Futur

### Avant de commencer
1. Lire **ce document en entier**
2. Avoir le **template de base** sous les yeux
3. Utiliser la **checklist** pour chaque endpoint

### Pendant la cr√©ation
1. **Un endpoint √† la fois** - Ne pas pr√©cipiter
2. **Valider au fur et √† mesure** - Pas attendre la fin
3. **Tester les exemples** - S'assurer qu'ils sont coh√©rents
4. **Documenter richement** - Descriptions claires et compl√®tes

### Apr√®s la cr√©ation
1. **Validation compl√®te** avec les outils
2. **Test import** dans ChatGPT/Factoria
3. **Commit dans Git** avec message descriptif
4. **Update ce document** si nouvelles erreurs d√©couvertes

---

## üÜò Debugging Guide

### Erreur : "responses.keys is not a function"
**Cause** : responses est un array  
**Solution** : Transformer en objet avec codes HTTP comme cl√©s

### Erreur : "array schema missing items"
**Cause** : `"type": "array"` sans `"items"`  
**Solution** : Ajouter `"items": {}` ou `"items": {"type": "string"}`

### Erreur : "schemas subsection is not an object"
**Cause** : `components.schemas` manquant ou null  
**Solution** : Ajouter `"schemas": {}` dans components

### Erreur : "reference to unknown component schema"
**Cause** : `$ref` pointe vers un sch√©ma inexistant  
**Solution** : Cr√©er le sch√©ma dans `components/schemas` ou utiliser une r√©f√©rence inline

### Erreur : "object schema missing properties"
**Cause** : `type: object` sans `properties`  
**Solution** : Ajouter `"properties": {}` m√™me si objet vide

### Erreur : "description has length X exceeding limit of 300"
**Cause** : Description trop longue  
**Solution** : R√©duire √† < 300 caract√®res, d√©tails dans `x-synesia`

### Erreur : "request body schema is not an object schema"
**Cause** : `oneOf` directement √† la racine du requestBody  
**Solution** : Utiliser `type: object` avec `additionalProperties: true` et diff√©rencier via `examples`

### Erreur : Factoria ne parse pas
**Causes possibles** :
1. ‚ùå Section `security` globale manquante ‚Üí Ajouter apr√®s `servers`
2. ‚ùå Responses en array ‚Üí Convertir en objet
3. ‚ùå Codes HTTP en number ‚Üí Mettre en string
4. ‚ùå Object sans properties ‚Üí Ajouter `properties: {}`
5. ‚ùå Description trop longue ‚Üí R√©duire √† < 300 caract√®res

---

## ‚ú® Template de Base (Copy-Paste Ready)

```json
{
  "openapi": "3.1.0",
  "info": {
    "title": "Synesia [NOM] API",
    "version": "1.0.0",
    "description": "Description de l'API"
  },
  "servers": [
    {
      "url": "https://api.synesia.app",
      "description": "API Server"
    }
  ],
  "security": [
    {
      "ApiKeyAuth": []
    }
  ],
  "components": {
    "schemas": {
      "SuccessResponse": {
        "type": "object",
        "required": ["data", "error"],
        "properties": {
          "data": {},
          "error": {"type": "null"}
        }
      },
      "ErrorResponse": {
        "type": "object",
        "required": ["data", "error"],
        "properties": {
          "data": {"type": "null"},
          "error": {"type": "string"}
        }
      }
    },
    "securitySchemes": {
      "ApiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "Authorization",
        "description": "Authentification par cl√© API. Format: ApiKey apiKey.{id}.{key}"
      }
    }
  },
  "paths": {}
}
```

---

## üéØ Checklist Finale (Avant Livraison)

Copier cette checklist pour chaque sch√©ma :

```markdown
## Sch√©ma : [NOM]

### Structure ‚úÖ
- [ ] openapi: "3.1.0"
- [ ] info (title, version, description)
- [ ] servers avec URL Synesia
- [ ] security global d√©fini
- [ ] components.schemas existe
- [ ] components.securitySchemes avec ApiKeyAuth

### Endpoints ‚úÖ
- [ ] Tous les endpoints document√©s
- [ ] Tags coh√©rents
- [ ] operationId uniques
- [ ] security d√©fini (sauf publics)

### Responses ‚úÖ
- [ ] Format OBJET (pas array)
- [ ] Codes HTTP en STRING
- [ ] 200, 400, 401 minimum
- [ ] Exemples fournis

### Validation ‚úÖ
- [ ] Pas d'array sans items
- [ ] Pas d'object sans properties
- [ ] Descriptions <= 300 caract√®res
- [ ] Pas de oneOf √† la racine du requestBody
- [ ] Pas d'erreur de syntaxe JSON
- [ ] Valid√© avec jq ou validator
- [ ] Test√© dans Swagger Editor
- [ ] Import√© avec succ√®s dans Factoria/ChatGPT

### Qualit√© ‚úÖ
- [ ] Descriptions claires
- [ ] Exemples r√©alistes
- [ ] Types pr√©cis
- [ ] $ref utilis√©s pour DRY
```

---

## üìû Contact

Si tu d√©couvres de nouvelles erreurs ou patterns, **UPDATE CE DOCUMENT** imm√©diatement pour aider les prochains agents !

**Maintenu par** : √âquipe Synesia  
**Derni√®re mise √† jour** : 2 octobre 2025  
**Version** : 1.0.0

---

## ü§ñ LLM Directives

**Section sp√©ciale pour les agents IA qui prendront le relais sur la cr√©ation de sch√©mas OpenAPI**

### üìê M√©thodologie Employ√©e (Approuv√©e et Test√©e)

#### Approche "Batch Validation" (5 par 5)

Cette m√©thode a prouv√© son efficacit√© pour cr√©er des sch√©mas complexes sans erreurs :

1. **Cr√©er 5 endpoints maximum** √† la fois
2. **Valider imm√©diatement** avec `read_lints`
3. **Si aucune erreur** ‚Üí Continuer avec les 5 suivants
4. **Si erreur** ‚Üí Corriger avant de continuer

**Pourquoi √ßa marche** :
- ‚úÖ √âvite l'accumulation d'erreurs
- ‚úÖ Permet de d√©tecter les patterns d'erreurs rapidement
- ‚úÖ R√©duit la charge cognitive
- ‚úÖ Facilite le debugging (scope limit√©)

**Exemple r√©el** :
```
Knowledges (19 endpoints) :
‚îú‚îÄ Batch 1 : Management (5) ‚Üí Valid√© ‚úÖ
‚îú‚îÄ Batch 2 : Search + Import (5) ‚Üí Valid√© ‚úÖ
‚îú‚îÄ Batch 3 : Entries CRUD (5) ‚Üí Valid√© ‚úÖ
‚îî‚îÄ Batch 4 : Datasets (4) ‚Üí Valid√© ‚úÖ
Result : 19 endpoints, z√©ro erreur ! üéâ
```

---

### üéØ Directives Strictes pour LLM

| # | Directive | Criticit√© | D√©tails |
|---|-----------|-----------|---------|
| 1 | **Responses = OBJET** | üî¥ CRITIQUE | `{"200": {...}}` jamais `[{status: 200}]` |
| 2 | **Codes HTTP = STRING** | üî¥ CRITIQUE | `"200"` jamais `200` |
| 3 | **Arrays ‚Üí items** | üî¥ CRITIQUE | Tout array DOIT avoir `"items"` |
| 4 | **Objects ‚Üí properties** | üî¥ CRITIQUE | Tout object DOIT avoir `"properties": {}` |
| 5 | **Security global** | üü† IMPORTANT | D√©clarer apr√®s `servers`, avant `components` |
| 6 | **components.schemas** | üü† IMPORTANT | Toujours `{}` minimum, jamais absent |
| 7 | **Descriptions ‚â§ 300 chars** | üü° REQUIS | Limite stricte ChatGPT/Factoria |
| 8 | **No oneOf in requestBody root** | üü° REQUIS | Utiliser `type: object` + `additionalProperties` |
| 9 | **Path params required: true** | üü° REQUIS | TOUJOURS `true` pour params dans le path |
| 10 | **Headers via description** | üü¢ RECOMMAND√â | Pas comme parameters (warnings) |

---

### ‚öôÔ∏è √âcriture M√©ticuleuse des Param√®tres

#### Path Parameters (TOUJOURS required: true)

```json
{
  "parameters": [
    {
      "name": "knowledge_id",
      "in": "path",
      "description": "ID de la knowledge",
      "required": true,  // ‚Üê OBLIGATOIRE pour path params
      "schema": {
        "type": "string"
      },
      "example": "know_abc123"  // ‚Üê Toujours un exemple r√©aliste
    }
  ]
}
```

**R√®gles** :
- ‚úÖ Nom exact tel que dans le path : `/knowledges/{knowledge_id}` ‚Üí `"name": "knowledge_id"`
- ‚úÖ `required: true` SANS EXCEPTION
- ‚úÖ Toujours un exemple concret
- ‚úÖ Description claire de ce que c'est

#### Query Parameters (required: false OK)

```json
{
  "parameters": [
    {
      "name": "limit",
      "in": "query",
      "description": "Nombre de r√©sultats √† retourner",
      "required": false,  // ‚Üê Peut √™tre false
      "schema": {
        "type": "integer",
        "minimum": 1,
        "maximum": 100,
        "default": 10  // ‚Üê Toujours indiquer le default
      }
    },
    {
      "name": "offset",
      "in": "query",
      "description": "D√©calage pour pagination",
      "required": false,
      "schema": {
        "type": "integer",
        "minimum": 0,
        "default": 0
      }
    }
  ]
}
```

**R√®gles** :
- ‚úÖ Indiquer `default` pour les params optionnels
- ‚úÖ Ajouter `minimum`/`maximum` pour les integers
- ‚úÖ Description du r√¥le du param√®tre

#### Header Parameters (√âVITER - documenter autrement)

‚ùå **Ne PAS faire** :
```json
{
  "parameters": [
    {
      "name": "Accept",
      "in": "header",  // ‚Üê ChatGPT va ignorer/warning
      "schema": {"type": "string"}
    }
  ]
}
```

‚úÖ **Faire √† la place** :

**Option A** : Documenter dans la description
```json
{
  "description": "Export le spreadsheet. Header Accept: application/json ou text/csv"
}
```

**Option B** : Si vraiment requis (Accept pour download)
```json
{
  "parameters": [
    {
      "name": "Accept",
      "in": "header",
      "description": "Format de t√©l√©chargement",
      "required": true,
      "schema": {
        "type": "string",
        "enum": ["application/json", "text/csv"]
      }
    }
  ]
}
```

---

### üî¨ Rigueur dans les Sch√©mas

#### RequestBody : Structure stricte

**Template √† suivre** :
```json
{
  "requestBody": {
    "required": true,  // ou false
    "description": "Description du body (< 300 chars)",
    "content": {
      "application/json": {
        "schema": {
          "type": "object",  // ‚Üê TOUJOURS object
          "required": ["champ1", "champ2"],  // ‚Üê Lister TOUS les champs requis
          "properties": {  // ‚Üê OBLIGATOIRE m√™me vide
            "champ1": {
              "type": "string",
              "description": "Description du champ",
              "example": "valeur exemple"  // ‚Üê Toujours un exemple
            },
            "champ_array": {
              "type": "array",
              "items": {"type": "string"},  // ‚Üê NE JAMAIS OUBLIER items
              "description": "Tableau de strings"
            },
            "champ_object": {
              "type": "object",
              "properties": {},  // ‚Üê NE JAMAIS OUBLIER properties
              "additionalProperties": true,
              "description": "Objet flexible"
            }
          }
        },
        "examples": {  // ‚Üê TOUJOURS au pluriel
          "cas1": {
            "summary": "Description du cas",
            "value": { ... }
          }
        }
      }
    }
  }
}
```

#### Responses : Triple v√©rification

**Checklist par endpoint** :

```markdown
Pour CHAQUE endpoint :
1. [ ] responses est un OBJET (pas array)
2. [ ] Au moins 200, 401
3. [ ] Codes en STRING ("200" pas 200)
4. [ ] Chaque response a "description"
5. [ ] Chaque response a "content" (sauf 204)
6. [ ] Schema avec type d√©fini
7. [ ] Example ou examples fourni
```

**Template responses complet** :
```json
{
  "responses": {
    "200": {
      "description": "Op√©ration r√©ussie",
      "content": {
        "application/json": {
          "schema": {
            "type": "object",
            "properties": {
              "data": { ... },
              "error": {"type": "null"}
            }
          },
          "example": { ... }  // ‚Üê Toujours un exemple concret
        }
      }
    },
    "400": {
      "description": "Donn√©es invalides",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/ErrorResponse"  // ‚Üê R√©utiliser
          }
        }
      }
    },
    "401": {
      "description": "Authentification invalide",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/ErrorResponse"
          }
        }
      }
    },
    "404": {  // ‚Üê Si l'endpoint acc√®de √† une ressource par ID
      "description": "Ressource non trouv√©e",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/ErrorResponse"
          }
        }
      }
    },
    "204": {  // ‚Üê Pour DELETE sans contenu
      "description": "Supprim√© avec succ√®s (pas de contenu)"
      // PAS de "content" pour 204
    }
  }
}
```

---

### üìä Sp√©cificit√©s Synesia

#### Format de R√©ponse Standard

**90% des endpoints Synesia** retournent :
```json
{
  "data": <r√©sultat ou null>,
  "error": <message d'erreur ou null>
}
```

**Exceptions** :
- Streaming (SSE) : text/event-stream
- Download (CSV) : text/csv
- DELETE : souvent 204 sans contenu
- Certains endpoints retournent directement (ex: search knowledge)

#### Authentication Patterns

**Pattern 1 : ApiKey standard (90% des endpoints)**
```json
{
  "security": [{"ApiKeyAuth": []}]  // Global + par endpoint
}
```

**Pattern 2 : Public total**
```json
{
  "security": []  // Vide = pas d'auth
}
```

**Pattern 3 : Optionnel (Webhooks)**
```json
{
  "security": [
    {"ApiKeyAuth": []},  // Option 1: Avec ApiKey
    {}                   // Option 2: Sans auth
  ]
}
```

#### Types de Content-Type

| Endpoint | Request | Response | Notes |
|----------|---------|----------|-------|
| Standard | `application/json` | `application/json` | 90% des cas |
| Upload | `multipart/form-data` | `application/json` | Storage, CSV import |
| Download | - | `text/csv` ou `application/json` | Export, via header Accept |
| Streaming | `application/json` | `text/event-stream` | LLM, Memory chat |

---

### üéì M√©thodologie de Cr√©ation (Step-by-Step)

#### Phase 1 : Pr√©paration (5 min)

```markdown
1. [ ] Lire le controller TypeScript concern√©
2. [ ] Identifier TOUS les endpoints (@Get, @Post, etc.)
3. [ ] Lire les types/interfaces (si fichier .types.ts existe)
4. [ ] V√©rifier les tests Bruno (si disponibles)
5. [ ] Lister les endpoints par ordre logique
```

#### Phase 2 : Structure de Base (2 min)

```markdown
1. [ ] Cr√©er le fichier JSON
2. [ ] Copier le template de base
3. [ ] Remplir info (title, version, description)
4. [ ] V√©rifier security global
5. [ ] Pr√©parer components.schemas vide
```

#### Phase 3 : Cr√©ation par Batch (10-15 min par batch)

```markdown
Pour chaque batch de 5 endpoints :

1. [ ] Cr√©er les 5 endpoints
2. [ ] V√©rifier CHAQUE endpoint individuellement :
   - [ ] responses en objet
   - [ ] codes HTTP en string
   - [ ] arrays avec items
   - [ ] objects avec properties
   - [ ] descriptions < 300 chars
   - [ ] examples fournis
3. [ ] Lancer read_lints
4. [ ] Si erreur : corriger imm√©diatement
5. [ ] Si OK : passer au batch suivant
```

#### Phase 4 : Finalisation (5 min)

```markdown
1. [ ] Ajouter section x-synesia avec notes
2. [ ] V√©rifier tous les $ref pointent bien vers components/schemas
3. [ ] V√©rification finale read_lints sur tout le fichier
4. [ ] Test manuel dans Swagger Editor (optionnel)
5. [ ] Commit avec message descriptif
```

---

### ‚ö†Ô∏è Erreurs √† √âviter Absolument

| ‚ùå Erreur | ‚úÖ Solution | Priorit√© |
|-----------|-------------|----------|
| `"responses": [{status: 200}]` | `"responses": {"200": {...}}` | üî¥ P0 |
| `"200": {...}` (number) | `"200": {...}` (string) | üî¥ P0 |
| `"type": "array"` sans items | `"type": "array", "items": {}` | üî¥ P0 |
| `"type": "object"` sans properties | `"type": "object", "properties": {}` | üî¥ P0 |
| Oublier `security` global | Ajouter apr√®s `servers` | üü† P1 |
| Description > 300 chars | R√©duire, mettre d√©tails dans x-synesia | üü° P2 |
| oneOf √† la racine requestBody | Utiliser object + additionalProperties | üü° P2 |
| Headers comme parameters | Documenter dans description | üü¢ P3 |

**Priorit√©** :
- üî¥ **P0** : Bloque ChatGPT/Factoria ‚Üí Corriger imm√©diatement
- üü† **P1** : Parsing incomplet ‚Üí √Ä corriger
- üü° **P2** : Warnings ou limitations ‚Üí Corriger si possible
- üü¢ **P3** : Best practices ‚Üí Nice to have

---

### üìù Checklist Op√©rationnelle (√Ä suivre RELIGIEUSEMENT)

#### Avant de commencer le fichier

```markdown
- [ ] J'ai lu les contr√¥leurs TypeScript
- [ ] J'ai identifi√© tous les endpoints
- [ ] J'ai compris les types d'entr√©e/sortie
- [ ] J'ai le template de base pr√™t
- [ ] Je connais le nombre total d'endpoints (pour planifier les batchs)
```

#### Pour CHAQUE endpoint cr√©√©

```markdown
Structure :
- [ ] tags d√©fini (cat√©gorie coh√©rente)
- [ ] summary d√©fini (< 50 chars)
- [ ] description d√©finie (< 300 chars)
- [ ] operationId unique et descriptif
- [ ] security d√©fini (ou override si public)

Parameters (si applicable) :
- [ ] Path params avec required: true
- [ ] Query params avec required et default
- [ ] Tous ont description et exemple
- [ ] Pas de headers (sauf Accept pour download)

RequestBody (si applicable) :
- [ ] required d√©fini (true/false)
- [ ] content avec type MIME correct
- [ ] schema avec type: "object"
- [ ] properties d√©fini (m√™me vide si additionalProperties)
- [ ] Champs required list√©s
- [ ] Tous les arrays ont items
- [ ] examples avec au moins 1 cas

Responses :
- [ ] Format OBJET (jamais array)
- [ ] Codes HTTP en STRING
- [ ] Au moins : 200, 401
- [ ] 400 si requestBody existe
- [ ] 404 si acc√®s par ID
- [ ] 204 pour DELETE sans contenu
- [ ] Chaque response a description
- [ ] Chaque response (sauf 204) a content
- [ ] Schema d√©fini avec type
- [ ] Example fourni

Validation :
- [ ] Aucun array sans items
- [ ] Aucun object sans properties
- [ ] Description < 300 caract√®res
- [ ] read_lints retourne 0 erreur
```

#### Apr√®s chaque batch de 5

```markdown
- [ ] read_lints ex√©cut√©
- [ ] 0 erreur retourn√©e
- [ ] Commit interm√©diaire (optionnel)
- [ ] Pause 30 sec pour relecture
- [ ] Continuer le batch suivant
```

#### Avant de livrer le fichier complet

```markdown
- [ ] read_lints final sur tout le fichier
- [ ] Tous les $ref sont valides
- [ ] Section x-synesia ajout√©e
- [ ] Historique mis √† jour dans OPENAPI_GUIDELINES.md
- [ ] Test dans Swagger Editor (si possible)
- [ ] Test import ChatGPT/Factoria (si possible)
```

---

### üß† Mental Model : Penser comme ChatGPT

ChatGPT est **strict** sur la structure. Pense comme √ßa :

#### Ce que ChatGPT EXIGE

1. **Structure rigide** :
   ```
   responses ‚Üí OBJET avec codes en string
   arrays ‚Üí TOUJOURS items
   objects ‚Üí TOUJOURS properties
   ```

2. **Typage fort** :
   ```
   requestBody.schema.type ‚Üí DOIT √™tre "object" ou type primitif
   Pas de oneOf/anyOf √† la racine
   ```

3. **Limites strictes** :
   ```
   description ‚Üí max 300 caract√®res
   ```

#### Ce que ChatGPT TOL√àRE

- ‚úÖ properties vide : `{}`
- ‚úÖ items vide : `{}`
- ‚úÖ additionalProperties : `true`
- ‚úÖ Exemples riches et multiples
- ‚úÖ Sections custom (x-synesia)

#### Ce que ChatGPT REJETTE

- ‚ùå responses en array
- ‚ùå oneOf direct dans requestBody
- ‚ùå array sans items
- ‚ùå object sans properties

**R√®gle d'or** : **Quand tu doutes ‚Üí Utilise le type le plus simple (object avec additionalProperties)**

---

### üé® Patterns Synesia √† Conna√Ætre

#### Pattern 1 : CRUD Standard

```json
GET    /resources           ‚Üí Liste (array)
POST   /resources           ‚Üí Cr√©e (retourne ID ou objet)
GET    /resources/{id}      ‚Üí R√©cup√®re (objet)
PATCH  /resources/{id}      ‚Üí Met √† jour (objet)
DELETE /resources/{id}      ‚Üí Supprime (204 no content)
```

#### Pattern 2 : Nested Resources

```json
GET    /knowledges/{id}/entries           ‚Üí Liste
POST   /knowledges/{id}/entries           ‚Üí Cr√©e
GET    /knowledges/{id}/entries/{eid}     ‚Üí R√©cup√®re
PATCH  /knowledges/{id}/entries/{eid}     ‚Üí Met √† jour
DELETE /knowledges/{id}/entries/{eid}     ‚Üí Supprime
```

**Attention** : 2 path params ‚Üí Bien tous les d√©clarer !

#### Pattern 3 : Actions/Dispatch

```json
POST /spreadsheets/{id}/dispatch
Body: {
  "action": {
    "type": "INSERT_ROW",
    "payload": { ... }
  }
}
```

**Traiter comme objet flexible** avec additionalProperties.

#### Pattern 4 : Query/Search

```json
POST /knowledges/{id}/search
Body: {
  "query": "...",
  "params": {"top_k": 5}
}
```

**Structure imbriqu√©e** ‚Üí Bien d√©finir chaque niveau.

#### Pattern 5 : Import/Upload

```json
POST /knowledges/{id}/import/csv
Content-Type: multipart/form-data
Body: {
  "file": <binary>,
  "method": <json-string>
}
```

**Attention** : 
- Content-Type = `multipart/form-data`
- file avec `format: binary`
- method peut √™tre string (JSON stringifi√©)

---

### üíé Best Practices Avanc√©es

#### 1. R√©utilisation Maximale (DRY)

Pour un sch√©ma avec 15+ endpoints, cr√©er dans `components/schemas` :

```json
{
  "components": {
    "schemas": {
      "Resource": { ... },           // Objet principal
      "CreateResourceInput": { ... }, // Input cr√©ation
      "UpdateResourceInput": { ... }, // Input update
      "SuccessResponse": { ... },     // R√©ponse succ√®s standard
      "ErrorResponse": { ... }        // R√©ponse erreur standard
    }
  }
}
```

**Ensuite** : R√©utiliser partout avec `$ref`

#### 2. Organisation des Tags

**Regrouper logiquement** :

```json
// Pour une API avec sous-ressources
"tags": ["Resource Management"]     // CRUD principal
"tags": ["Resource Entries"]        // CRUD des entr√©es
"tags": ["Resource Actions"]        // Actions sp√©ciales
"tags": ["Resource Import"]         // Import de donn√©es
"tags": ["Resource Export"]         // Export de donn√©es
```

**B√©n√©fice** : Navigation claire dans Swagger/ChatGPT

#### 3. Examples Strat√©giques

**Toujours 2-3 exemples minimum** :

```json
{
  "examples": {
    "simple": {
      "summary": "Cas d'usage simple",
      "value": { ... }
    },
    "complex": {
      "summary": "Cas avanc√© avec toutes les options",
      "value": { ... }
    },
    "edge_case": {
      "summary": "Cas limite ou sp√©cial",
      "value": { ... }
    }
  }
}
```

---

### üö® Pi√®ges Fr√©quents et Solutions

#### Pi√®ge 1 : Oublier items dans un nested array

```json
// ‚ùå PI√àGE
{
  "tools": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "sub_tools": {
          "type": "array"  // ‚Üê Oubli√© items ici !
        }
      }
    }
  }
}

// ‚úÖ CORRECT
{
  "tools": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        "sub_tools": {
          "type": "array",
          "items": {"type": "string"}  // ‚Üê Items pr√©sent
        }
      }
    }
  }
}
```

**Solution** : Scanner TOUS les "type": "array" dans le fichier

#### Pi√®ge 2 : Description qui d√©borde

```json
// ‚ùå PI√àGE (305 caract√®res)
"description": "Cet endpoint permet de cr√©er une nouvelle ressource dans le syst√®me. Il accepte plusieurs formats de donn√©es et effectue une validation compl√®te. Les donn√©es sont ensuite stock√©es de mani√®re s√©curis√©e dans la base de donn√©es. Le syst√®me g√©n√®re automatiquement un ID unique et retourne l'objet cr√©√©."

// ‚úÖ CORRECT (158 caract√®res)
"description": "Cr√©e une nouvelle ressource avec validation. Les donn√©es sont stock√©es de mani√®re s√©curis√©e et un ID unique est g√©n√©r√© automatiquement."
```

**Astuce** : Compte avant d'√©crire. Si long ‚Üí section x-synesia.

#### Pi√®ge 3 : M√©langer les formats de codes HTTP

```json
// ‚ùå PI√àGE (inconsistant)
{
  "responses": {
    "200": { ... },   // String
    400: { ... },     // Number ‚Üê ERREUR
    "404": { ... }    // String
  }
}

// ‚úÖ CORRECT (tout en string)
{
  "responses": {
    "200": { ... },
    "400": { ... },
    "404": { ... }
  }
}
```

**Solution** : TOUJOURS string, m√™me pour 200.

---

### üéØ Commandes de Validation

#### Pendant la cr√©ation

```bash
# Apr√®s chaque batch
jq empty openapi-schemas/mon-schema.json && echo "‚úÖ Valid JSON" || echo "‚ùå Invalid JSON"
```

#### Avant de livrer

```bash
# Validation syntax
jq . openapi-schemas/mon-schema.json > /dev/null

# Validation OpenAPI (si install√©)
npx @apidevtools/swagger-cli validate openapi-schemas/mon-schema.json

# Compter les endpoints
jq '.paths | to_entries | map(.value | keys) | flatten | length' openapi-schemas/mon-schema.json
```

---

### üì¶ Livrables Attendus

Pour un sch√©ma complet, tu dois livrer :

1. **Fichier JSON valide** (`nom-api.json`)
   - ‚úÖ Structure OpenAPI 3.1.0 compl√®te
   - ‚úÖ Z√©ro erreur de lint
   - ‚úÖ Tous les endpoints document√©s

2. **Section x-synesia** (dans le JSON)
   - Notes techniques
   - Use cases
   - Sp√©cificit√©s d'impl√©mentation

3. **Update OPENAPI_GUIDELINES.md**
   - Ajouter ligne dans "Historique des Sch√©mas Cr√©√©s"
   - Documenter nouvelles erreurs (si rencontr√©es)

4. **Test de validation** (preuve)
   - Screenshot Swagger Editor (optionnel)
   - Confirmation import ChatGPT (optionnel)
   - Message "read_lints : 0 erreur"

---

### üîÑ Workflow Complet (Exemple R√©el)

#### Exemple : Cr√©er "Knowledges API" (19 endpoints)

```
üìã Planification
‚îú‚îÄ Batch 1 : Management CRUD (5 endpoints)
‚îú‚îÄ Batch 2 : Search + Import (5 endpoints)
‚îú‚îÄ Batch 3 : Entries CRUD (5 endpoints)
‚îî‚îÄ Batch 4 : Datasets (4 endpoints)

‚è±Ô∏è Temps estim√© : 40-60 min

üöÄ Ex√©cution :

[Batch 1] - 10 min
‚îú‚îÄ Cr√©er structure de base
‚îú‚îÄ Ajouter GET/POST /knowledges
‚îú‚îÄ Ajouter GET/PATCH/DELETE /knowledges/{id}
‚îú‚îÄ V√©rifier chaque endpoint (checklist)
‚îú‚îÄ read_lints ‚Üí 0 erreur ‚úÖ
‚îî‚îÄ Continue !

[Batch 2] - 12 min
‚îú‚îÄ Ajouter POST /knowledges/{id}/search
‚îú‚îÄ Ajouter 4 endpoints import (csv, text, text-file, document)
‚îú‚îÄ V√©rifier multipart/form-data pour CSV
‚îú‚îÄ read_lints ‚Üí 0 erreur ‚úÖ
‚îî‚îÄ Continue !

[Batch 3] - 10 min
‚îú‚îÄ Ajouter GET/POST /knowledges/{id}/entries
‚îú‚îÄ Ajouter GET/PATCH/DELETE /knowledges/{id}/entries/{eid}
‚îú‚îÄ V√©rifier nested path params
‚îú‚îÄ read_lints ‚Üí 0 erreur ‚úÖ
‚îî‚îÄ Continue !

[Batch 4] - 8 min
‚îú‚îÄ Ajouter 4 endpoints datasets
‚îú‚îÄ V√©rifier export CSV (text/csv)
‚îú‚îÄ read_lints ‚Üí 0 erreur ‚úÖ
‚îî‚îÄ Termin√© !

[Finalisation] - 5 min
‚îú‚îÄ Ajouter section x-synesia
‚îú‚îÄ Validation finale
‚îú‚îÄ Update guidelines.md
‚îî‚îÄ Commit ‚úÖ

‚úÖ R√©sultat : 19 endpoints, 0 erreur, 45 min
```

---

### üéñÔ∏è Standards de Qualit√©

Un sch√©ma de **qualit√© production** doit avoir :

#### Niveau Minimum ‚≠ê

- ‚úÖ Structure OpenAPI 3.1.0 valide
- ‚úÖ Tous les endpoints document√©s
- ‚úÖ Authentification configur√©e
- ‚úÖ 0 erreur de lint

#### Niveau Professionnel ‚≠ê‚≠ê

- ‚úÖ Minimum +
- ‚úÖ Sch√©mas r√©utilisables dans components
- ‚úÖ Examples pour chaque requestBody
- ‚úÖ Descriptions claires < 300 chars
- ‚úÖ Tags coh√©rents

#### Niveau Excellence ‚≠ê‚≠ê‚≠ê (Cible)

- ‚úÖ Professionnel +
- ‚úÖ Examples multiples (2-3 par endpoint)
- ‚úÖ Section x-synesia avec notes techniques
- ‚úÖ Tous les edge cases document√©s
- ‚úÖ Test√© dans ChatGPT/Swagger

**Viser TOUJOURS le niveau Excellence** pour Synesia !

---

### üìê Template de Commit Message

```
feat(openapi): Add [NOM] API schema ([X] endpoints)

- CRUD operations: [liste]
- Special features: [liste]
- Total endpoints: X
- Validation: ‚úÖ 0 errors

Schemas created:
- [Schema1]
- [Schema2]

Tested with: ChatGPT ‚úÖ, Swagger Editor ‚úÖ
```

**Exemple r√©el** :
```
feat(openapi): Add Knowledges API schema (19 endpoints)

- Management: CRUD knowledges
- Import: CSV, text, documents with chunking
- Entries: Full CRUD with pagination
- Datasets: Search, insert, export CSV
- Total endpoints: 19
- Validation: ‚úÖ 0 errors

Schemas created:
- Knowledge
- KnowledgeEntry
- SuccessResponse
- ErrorResponse

Tested with: ChatGPT ‚úÖ, Factoria ‚úÖ
```

---

### üéØ KPIs de Performance

Pour mesurer la qualit√© de ton travail :

| M√©trique | Cible | Excellence |
|----------|-------|------------|
| Erreurs de lint | 0 | 0 |
| Endpoints sans exemple | 0% | 0% |
| Descriptions > 300 chars | 0% | 0% |
| Arrays sans items | 0 | 0 |
| Objects sans properties | 0 | 0 |
| Temps par endpoint | < 3 min | < 2 min |
| Batchs sans erreur | 100% | 100% |
| R√©visions n√©cessaires | < 2 | 0 |

**Si tu atteins ces KPIs** ‚Üí Tu es au niveau de qualit√© Synesia ! üèÜ

---

### üîÆ Debugging Rapide

Si ChatGPT/Factoria refuse ton sch√©ma :

```
1. Cherche "responses" ‚Üí V√©rifie format objet
2. Cherche "type": "array" ‚Üí V√©rifie items partout
3. Cherche "type": "object" ‚Üí V√©rifie properties partout
4. Cherche "description" ‚Üí Compte les caract√®res
5. Cherche "security" ‚Üí V√©rifie pr√©sence au niveau root
6. Cherche requestBody ‚Üí V√©rifie pas de oneOf direct
7. Lance read_lints ‚Üí Corrige tout
```

**90% des erreurs** sont dans ces 7 points !

---

### üí™ Ton R√¥le en tant qu'Agent OpenAPI

Tu n'es pas juste un "g√©n√©rateur de JSON". Tu es un **architecte de documentation API**.

**Ton job** :
1. ‚úÖ Garantir 100% de validit√© technique
2. ‚úÖ Rendre l'API **compr√©hensible** (descriptions, exemples)
3. ‚úÖ Faciliter l'**int√©gration** (exemples r√©alistes)
4. ‚úÖ Maintenir la **coh√©rence** (patterns, naming)
5. ‚úÖ Documenter les **edge cases** (x-synesia)

**Standards Synesia** :
- üéØ **Z√©ro erreur** tol√©r√©e
- üéØ **Qualit√© production** syst√©matique
- üéØ **Documentation riche** (pas le minimum)
- üéØ **Validation rigoureuse** (batch par batch)

**Tu repr√©sentes la qualit√© de Synesia** ‚Üí Exigence maximale ! üöÄ

---

**üåü Bonne chance, agent futur ! Ce guide est l√† pour t'√©viter les gal√®res qu'on a eues. Lis-le attentivement avant de commencer !** üöÄ

