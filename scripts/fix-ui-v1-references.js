#!/usr/bin/env node

/**
 * Script de correction des r√©f√©rences : /api/ui/v1/ ‚Üí /api/ui/
 * 
 * Apr√®s avoir d√©plac√© le contenu de v1 vers ui, il faut mettre √† jour
 * toutes les r√©f√©rences dans le code
 */

const fs = require('fs');
const path = require('path');

// Configuration
const ROOT_DIR = path.join(__dirname, '..');
const SEARCH_PATTERN = /\/api\/ui\/v1\//g;
const REPLACEMENT = '/api/ui/';

// Extensions de fichiers √† traiter
const FILE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.json', '.md'];

// Fichiers et dossiers √† ignorer
const IGNORE_PATTERNS = [
  'node_modules',
  '.git',
  '.next',
  'dist',
  'build',
  'coverage',
  'scripts/fix-ui-v1-references.js'
];

/**
 * V√©rifie si un chemin doit √™tre ignor√©
 */
function shouldIgnorePath(filePath) {
  return IGNORE_PATTERNS.some(pattern => filePath.includes(pattern));
}

/**
 * R√©cup√®re tous les fichiers r√©cursivement
 */
function getAllFiles(dir, files = []) {
  const items = fs.readdirSync(dir);
  
  for (const item of items) {
    const fullPath = path.join(dir, item);
    
    if (shouldIgnorePath(fullPath)) {
      continue;
    }
    
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory()) {
      getAllFiles(fullPath, files);
    } else if (stat.isFile() && FILE_EXTENSIONS.includes(path.extname(item))) {
      files.push(fullPath);
    }
  }
  
  return files;
}

/**
 * Traite un fichier pour remplacer les r√©f√©rences
 */
function processFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    
    // V√©rifier si le fichier contient des r√©f√©rences √† /api/ui/v1/
    if (!SEARCH_PATTERN.test(content)) {
      return { processed: false, changes: 0 };
    }
    
    // Remplacer les r√©f√©rences
    const newContent = content.replace(SEARCH_PATTERN, REPLACEMENT);
    const changes = (content.match(SEARCH_PATTERN) || []).length;
    
    // √âcrire le fichier modifi√©
    fs.writeFileSync(filePath, newContent, 'utf8');
    
    return { processed: true, changes };
  } catch (error) {
    console.error(`‚ùå Erreur lors du traitement de ${filePath}:`, error.message);
    return { processed: false, error: error.message };
  }
}

/**
 * Fonction principale
 */
function main() {
  console.log('üöÄ Correction des r√©f√©rences /api/ui/v1/ ‚Üí /api/ui/');
  console.log('====================================================');
  
  // R√©cup√©rer tous les fichiers
  console.log('üîç Recherche des fichiers...');
  const files = getAllFiles(ROOT_DIR);
  console.log(`üìÅ ${files.length} fichiers trouv√©s`);
  
  // Statistiques
  let totalProcessed = 0;
  let totalChanges = 0;
  let totalErrors = 0;
  const processedFiles = [];
  const errorFiles = [];
  
  // Traiter chaque fichier
  console.log('\nüîÑ Traitement des fichiers...');
  for (const file of files) {
    const relativePath = path.relative(ROOT_DIR, file);
    const result = processFile(file);
    
    if (result.processed) {
      totalProcessed++;
      totalChanges += result.changes;
      processedFiles.push({ file: relativePath, changes: result.changes });
      
      if (result.changes > 0) {
        console.log(`‚úÖ ${relativePath} (${result.changes} changements)`);
      }
    } else if (result.error) {
      totalErrors++;
      errorFiles.push({ file: relativePath, error: result.error });
      console.log(`‚ùå ${relativePath} - Erreur: ${result.error}`);
    }
  }
  
  // R√©sum√©
  console.log('\nüìä R√âSUM√â DE LA CORRECTION');
  console.log('==============================');
  console.log(`‚úÖ Fichiers trait√©s avec succ√®s: ${totalProcessed}`);
  console.log(`üîÑ Total des changements: ${totalChanges}`);
  console.log(`‚ùå Fichiers en erreur: ${totalErrors}`);
  
  if (processedFiles.length > 0) {
    console.log('\nüìù FICHIERS MODIFI√âS:');
    processedFiles.forEach(({ file, changes }) => {
      if (changes > 0) {
        console.log(`  ‚Ä¢ ${file} (${changes} changements)`);
      }
    });
  }
  
  if (errorFiles.length > 0) {
    console.log('\nüö® FICHIERS EN ERREUR:');
    errorFiles.forEach(({ file, error }) => {
      console.log(`  ‚Ä¢ ${file}: ${error}`);
    });
  }
  
  // V√©rification finale
  console.log('\nüîç V√©rification finale...');
  const remainingV1Refs = getAllFiles(ROOT_DIR).filter(file => {
    try {
      const content = fs.readFileSync(file, 'utf8');
      return SEARCH_PATTERN.test(content);
    } catch {
      return false;
    }
  });
  
  if (remainingV1Refs.length === 0) {
    console.log('‚úÖ Aucune r√©f√©rence √† /api/ui/v1/ restante !');
  } else {
    console.log(`‚ö†Ô∏è  ${remainingV1Refs.length} fichiers contiennent encore des r√©f√©rences √† /api/ui/v1/`);
    remainingV1Refs.forEach(file => {
      const relativePath = path.relative(ROOT_DIR, file);
      console.log(`  ‚Ä¢ ${relativePath}`);
    });
  }
  
  console.log('\nüéâ Correction termin√©e !');
  
  if (totalErrors > 0) {
    console.log('\n‚ö†Ô∏è  ATTENTION: Certains fichiers n\'ont pas pu √™tre trait√©s.');
    console.log('   V√©rifiez les erreurs ci-dessus et relancez le script si n√©cessaire.');
    process.exit(1);
  }
}

// Ex√©cuter le script
main();
